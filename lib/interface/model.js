// Generated by CoffeeScript 1.7.1
(function() {
  var Model, ModelError, ValueError, async, extendOnClass, isPojo, objectdiff, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  async = require('async');

  objectdiff = require('objectdiff');

  extendOnClass = require('extendonclass').extendOnClass;

  isPojo = require('./utils').isPojo;

  ValueError = (function(_super) {
    __extends(ValueError, _super);

    function ValueError() {
      return ValueError.__super__.constructor.apply(this, arguments);
    }

    return ValueError;

  })(Error);

  ModelError = (function(_super) {
    __extends(ModelError, _super);

    function ModelError() {
      return ModelError.__super__.constructor.apply(this, arguments);
    }

    return ModelError;

  })(Error);

  Model = (function() {
    Model.extend = extendOnClass;

    Model.prototype.db = null;

    Model.prototype.meta = null;

    Model.prototype.schema = _.clone({
      _id: {
        readOnly: true,
        type: 'string'
      },
      _type: {
        "protected": true,
        type: 'string',
        "default": function(model) {
          return model.meta.name;
        }
      }
    });

    function Model(properties) {
      this.toJSON = __bind(this.toJSON, this);
      this.toJSONObject = __bind(this.toJSONObject, this);
      this.isNew = __bind(this.isNew, this);
      this["delete"] = __bind(this["delete"], this);
      this.rollback = __bind(this.rollback, this);
      this.save = __bind(this.save, this);
      this.clear = __bind(this.clear, this);
      this.isPopulated = __bind(this.isPopulated, this);
      this.has = __bind(this.has, this);
      this.unset = __bind(this.unset, this);
      this.pull = __bind(this.pull, this);
      this.push = __bind(this.push, this);
      this.set = __bind(this.set, this);
      this.describe = __bind(this.describe, this);
      this.getLabel = __bind(this.getLabel, this);
      this.getInstance = __bind(this.getInstance, this);
      this.get = __bind(this.get, this);
      var field, fieldName, fieldType, key, val, value, _ref;
      properties = properties || {};
      this._properties = {};
      this._instances = {};
      this._cachedProperties = {};
      this._isNew = true;
      for (key in properties) {
        value = properties[key];
        fieldType = this.schema[key].type;
        if (_.isObject(key) && (this.db[fieldType] != null)) {
          if (_.isArray(value)) {
            value = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = value.length; _i < _len; _i++) {
                val = value[_i];
                _results.push(_.isObject(val) && this.db[fieldType](val) || val);
              }
              return _results;
            }).call(this);
          } else {
            value = new this.db[fieldType](value);
          }
        }
        this.set(key, value);
      }
      _ref = this.schema;
      for (fieldName in _ref) {
        field = _ref[fieldName];
        if ((field["default"] != null) && (properties[fieldName] == null)) {
          if (_.isFunction(field["default"])) {
            value = field["default"](this);
          } else {
            value = field["default"];
          }
          this.set(fieldName, value, {
            quietReadOnly: true
          });
        }
      }
      this._updateCachedProperties();
    }

    Model.beforeQuery = function(query, options, callback) {
      var e;
      try {
        this._validateQuery(this, query);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      return callback(null, query, options);
    };

    Model.count = function(query, options, callback) {
      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!callback && typeof query === 'function') {
        callback = query;
        options = {};
        query = {};
      }
      if (query._type == null) {
        query._type = this.prototype.meta.type;
      }
      return this.beforeQuery(query, options, (function(_this) {
        return function(err, query, options) {
          if (err) {
            return callback(err);
          }
          return _this.db.count(query, options, callback);
        };
      })(this));
    };

    Model.find = function(query, options, callback) {
      if (!callback && typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!callback && typeof query === 'function') {
        callback = query;
        query = {};
        options = {};
      }
      if (!callback) {
        throw 'callback is required';
      }
      if (query._type == null) {
        query._type = this.prototype.meta.type;
      }
      return this.beforeQuery(query, options, (function(_this) {
        return function(err, query, options) {
          if (err) {
            return callback(err);
          }
          return _this.db.find(query, options, function(err, pojos) {
            var instances, pojo;
            if (err) {
              return callback(err);
            }
            instances = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = pojos.length; _i < _len; _i++) {
                pojo = pojos[_i];
                _results.push(new this(pojo));
              }
              return _results;
            }).call(_this);
            if (options.populate) {
              return async.map(instances, function(instance, cb) {
                var fields, fname, populateOptions, val;
                populateOptions = {};
                if (_.isNumber(options.populate)) {
                  fields = (function() {
                    var _ref, _results;
                    _ref = this.schema;
                    _results = [];
                    for (fname in _ref) {
                      val = _ref[fname];
                      if (this.db[val.type] != null) {
                        _results.push(fname);
                      }
                    }
                    return _results;
                  }).call(this);
                } else {
                  fields = null;
                  populateOptions.recursive = true;
                }
                return instance.populate(fields, populateOptions, cb);
              }, function(err, data) {
                if (err) {
                  return callback(err);
                }
                return callback(null, instances);
              });
            } else {
              return callback(null, instances);
            }
          });
        };
      })(this));
    };

    Model.findIDs = function(query, options, callback) {
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = {};
      }
      if (!callback) {
        throw 'callback is required';
      }
      options.instance = false;
      return this.find(query, options, callback);
    };

    Model.first = function(query, options, callback) {
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = {};
      }
      if (!callback) {
        throw 'callback is required';
      }
      options.limit = 1;
      return this.find(query, options, function(err, pojos) {
        if (err) {
          return callback(err);
        }
        if (!pojos.length) {
          return callback(null, null);
        }
        return callback(null, pojos[0]);
      });
    };

    Model.firstID = function(query, options, callback) {
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = {};
      }
      if (!callback) {
        throw 'callback is required';
      }
      options.instance = false;
      return this.first(query, options, callback);
    };

    Model.facets = function(field, query, options, callback) {
      return 'facets() not implemented';
    };

    Model.prototype.populate = function(fields, options, callback) {
      var fieldName, fname, relId, relationFieldNames, relationId, relationIds, relationInstances, val, _i, _j, _len, _len1;
      if (typeof fields === 'function' && !callback) {
        callback = fields;
        options = {};
        fields = null;
      }
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = {};
      }
      if (_.isObject(fields) && !_.isArray(fields)) {
        options = fields;
        fields = null;
      }
      if (!(_.isArray(fields) && fields.length > 0)) {
        fields = (function() {
          var _ref, _results;
          _ref = this.schema;
          _results = [];
          for (fname in _ref) {
            val = _ref[fname];
            if (this.db[val.type] != null) {
              _results.push(fname);
            }
          }
          return _results;
        }).call(this);
      }
      relationFieldNames = {};
      relationInstances = {};
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        fieldName = fields[_i];
        relationId = this.get(fieldName);
        if (relationId) {
          if (_.isString(relationId)) {
            relationId = [relationId];
          }
          relationFieldNames[fieldName] = {
            id: relationId,
            model: this.db[this.schema[fieldName].type]
          };
          for (_j = 0, _len1 = relationId.length; _j < _len1; _j++) {
            relId = relationId[_j];
            relationInstances[relId] = {
              model: this.db[this.schema[fieldName].type]
            };
          }
        }
      }
      relationIds = _.keys(relationInstances);
      return this.db.find(relationIds, (function(_this) {
        return function(err, data) {
          var id, instance, instancesToPopulate, pojo, relinfo, rinfo, _k, _len2;
          if (err) {
            return callback(err);
          }
          for (_k = 0, _len2 = data.length; _k < _len2; _k++) {
            pojo = data[_k];
            rinfo = relationInstances[pojo._id];
            relationInstances[pojo._id].instance = new rinfo.model(pojo);
          }
          instancesToPopulate = [];
          for (fieldName in relationFieldNames) {
            relinfo = relationFieldNames[fieldName];
            if (_this.schema[fieldName].multi) {
              instance = (function() {
                var _l, _len3, _ref, _results;
                _ref = relinfo.id;
                _results = [];
                for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
                  id = _ref[_l];
                  _results.push(relationInstances[id].instance);
                }
                return _results;
              })();
            } else {
              instance = relationInstances[relinfo.id].instance;
            }
            _this.set(fieldName, instance);
            if (options.recursive) {
              instancesToPopulate = _.union(instancesToPopulate, instance);
            }
          }
          if (options.recursive) {
            return async.map(instancesToPopulate, function(instance, cb) {
              return instance.populate(options, cb);
            }, function(err, data) {
              if (err) {
                return callback(err);
              }
              return callback(null, _this);
            });
          } else {
            return callback(null, _this);
          }
        };
      })(this));
    };

    Model.prototype.batchPopulate = function(instances, options, callback) {};

    Model.prototype.get = function(fieldName, options) {
      var lang;
      this.__checkFieldExistance(fieldName);
      options = this.__parseOptions(options, {
        validate: true,
        quietReadOnly: false
      }, fieldName);
      if (this.schema[fieldName].i18n) {
        if (this._properties[fieldName] == null) {
          this._properties[fieldName] = {};
        }
        lang = options.lang;
        return this._properties[fieldName][lang];
      }
      return this._properties[fieldName];
    };

    Model.prototype.getInstance = function(fieldName, options) {
      return this.__checkFieldExistance(fieldName);
    };

    Model.prototype.getLabel = function(fieldName, options) {
      var label, lang;
      this.__checkFieldExistance(fieldName);
      options = options || {};
      if (_.isString(options)) {
        options = {
          lang: options
        };
      }
      lang = options.lang;
      label = this.schema[fieldName].label;
      if (_.isObject(label)) {
        label = label[lang];
      }
      if (!label) {
        label = fieldName.toLowerCase();
      }
      return label;
    };

    Model.prototype.describe = function(fieldName, options) {};

    Model.prototype.set = function(fieldName, value, options) {
      var checkLang, i18nValue, item, lang, val, valitem, _i, _len, _ref, _ref1, _ref2, _results, _results1;
      options = options || {};
      if (value === null || value === (void 0)) {
        this.unset(fieldName, options);
        return;
      }
      this.__checkFieldExistance(fieldName);
      checkLang = fieldName;
      if (isPojo(value) && (((_ref = value.meta) != null ? _ref.name : void 0) == null)) {
        checkLang = null;
      }
      options = this.__parseOptions(options, {
        validate: true,
        quietReadOnly: false
      }, checkLang);
      if (this.schema[fieldName].readOnly) {
        if ((!this.schema[fieldName].i18n && (this._properties[fieldName] != null)) || (this.schema[fieldName].i18n && (((_ref1 = this._properties[fieldName]) != null ? _ref1[options.lang] : void 0) != null))) {
          if (options.quietReadOnly) {
            return;
          }
          throw new ValueError("" + this.meta.name + "." + fieldName + " is read-only");
        }
      }
      if (_.isArray(value)) {
        if (!this.schema[fieldName].multi) {
          throw new ValueError("" + this.meta.name + "." + fieldName + " doesn't accept array");
        }
        options.quietReadOnly = true;
        this.unset(fieldName, options);
        _results = [];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          item = value[_i];
          _results.push(this.push(fieldName, item, options));
        }
        return _results;
      } else {
        if (this.schema[fieldName].i18n) {
          if (this._properties[fieldName] == null) {
            this._properties[fieldName] = {};
          }
          if (isPojo(value) && !((_ref2 = value.meta) != null ? _ref2.name : void 0)) {
            i18nValue = value;
          } else {
            lang = options.lang;
            i18nValue = {};
            i18nValue[lang] = value;
          }
          _results1 = [];
          for (lang in i18nValue) {
            val = i18nValue[lang];
            if (isPojo(value) && this.schema[fieldName].multi) {
              _results1.push((function() {
                var _j, _len1, _results2;
                _results2 = [];
                for (_j = 0, _len1 = val.length; _j < _len1; _j++) {
                  valitem = val[_j];
                  _results2.push(this.push(fieldName, valitem, lang));
                }
                return _results2;
              }).call(this));
            } else {
              val = this.__processValue(val, {
                fieldName: fieldName,
                lang: lang,
                model: this
              });
              _results1.push(this._properties[fieldName][lang] = val);
            }
          }
          return _results1;
        } else {
          value = this.__processValue(value, {
            fieldName: fieldName,
            model: this
          });
          if (fieldName === '_id') {
            this.id = value;
          } else if (fieldName === '_type') {
            this.type = value;
          }
          return this._properties[fieldName] = value;
        }
      }
    };

    Model.prototype.push = function(fieldName, value, options) {
      var lang, _ref;
      this.__checkFieldExistance(fieldName);
      options = this.__parseOptions(options, {
        validate: true,
        quietReadOnly: false
      }, fieldName);
      if (!this.schema[fieldName].multi) {
        throw new ValueError("" + this.meta.name + "." + fieldName + " is not a multi field");
      }
      if (this.schema[fieldName].readOnly) {
        if ((!this.schema[fieldName].i18n && (this._properties[fieldName] != null)) || (this.schema[fieldName].i18n && (((_ref = this._properties[fieldName]) != null ? _ref[options.lang] : void 0) != null))) {
          if (options.quietReadOnly) {
            return;
          }
          throw new ValueError("" + this.meta.name + "." + fieldName + " is read-only");
        }
      }
      if (this.schema[fieldName].i18n) {
        if (this._properties[fieldName] == null) {
          this._properties[fieldName] = {};
        }
        lang = options.lang;
        if (this._properties[fieldName][lang] == null) {
          this._properties[fieldName][lang] = [];
        }
        value = this.__processValue(value, {
          fieldName: fieldName,
          lang: lang,
          model: this
        });
        return this._properties[fieldName][lang].push(value);
      } else {
        if (!this._properties[fieldName]) {
          this._properties[fieldName] = [];
        }
        value = this.__processValue(value, {
          fieldName: fieldName,
          model: this
        });
        return this._properties[fieldName].push(value);
      }
    };

    Model.prototype.pull = function(fieldName, value, options) {
      var lang, values, _ref;
      this.__checkFieldExistance(fieldName);
      options = this.__parseOptions(options, {
        quietReadOnly: false
      }, fieldName);
      if (!this.schema[fieldName].multi) {
        throw new ValueError("" + this.meta.name + "." + fieldName + " is not a multi field");
      }
      if (this.schema[fieldName].readOnly) {
        if (options.quietReadOnly) {
          return;
        }
        throw new ValueError("" + this.meta.name + "." + fieldName + " is read-only");
      }
      if (this.schema[fieldName].i18n) {
        lang = options.lang;
        if (((_ref = this._properties[fieldName]) != null ? _ref[lang] : void 0) != null) {
          values = _.without(this._properties[fieldName][lang], value);
          return this._properties[fieldName][lang] = values;
        }
      } else {
        if (this._properties[fieldName]) {
          values = _.without(this._properties[fieldName], value);
          return this._properties[fieldName] = values;
        }
      }
    };

    Model.prototype.unset = function(fieldName, options) {
      var lang, _ref;
      options = options || {};
      this.__checkFieldExistance(fieldName);
      if (this.schema[fieldName].readOnly) {
        if (options.quietReadOnly) {
          return;
        }
        throw new ValueError("" + this.meta.name + "." + fieldName + " is read-only");
      }
      if (this.schema[fieldName].i18n) {
        if (_.isString(options)) {
          options = {
            lang: options
          };
        }
        if (options.lang != null) {
          lang = options.lang;
          if (((_ref = this._properties[fieldName]) != null ? _ref[lang] : void 0) != null) {
            return delete this._properties[fieldName][lang];
          }
        }
      } else {
        return delete this._properties[fieldName];
      }
    };

    Model.prototype.has = function(fieldName, options) {
      var lang, _ref;
      if (this.schema[fieldName] == null) {
        return false;
      }
      options = this.__parseOptions(options, {
        validate: true
      }, fieldName);
      if (_.isString(options)) {
        if (this.schema[fieldName].i18n) {
          options = {
            lang: options
          };
        }
      }
      if (this.schema[fieldName].i18n) {
        lang = options.lang;
        return ((_ref = this._properties[fieldName]) != null ? _ref[lang] : void 0) != null;
      }
      return this._properties[fieldName] != null;
    };

    Model.prototype.isPopulated = function(fieldName) {
      return this.__checkFieldExistance(fieldName);
    };

    Model.prototype.clear = function() {
      this._properties = {};
      return this._instances = {};
    };

    Model.prototype.hasChanged = function() {
      return this.changes() !== null;
    };

    Model.prototype.changes = function() {
      var added, diff, fieldName, index, infos, lang, linfos, minfos, mlinfos, removed, setDiff, setValue, _ref, _ref1, _ref2, _ref3;
      setValue = function(target, fieldName, value, options) {
        var i18n, lang, multi;
        options = options || {};
        i18n = options.i18n || false;
        multi = options.multi || false;
        lang = options.lang;
        if (i18n) {
          if (target[fieldName] == null) {
            target[fieldName] = {};
          }
          if (multi) {
            if (target[fieldName][lang] == null) {
              target[fieldName][lang] = [];
            }
            return target[fieldName][lang].push(value);
          } else {
            return target[fieldName][lang] = value;
          }
        } else if (multi) {
          if (target[fieldName] == null) {
            target[fieldName] = [];
          }
          return target[fieldName].push(value);
        } else {
          return target[fieldName] = value;
        }
      };
      setDiff = function(fieldName, infos, options) {
        if (infos.changed === 'added') {
          return setValue(added, fieldName, infos.value, options);
        } else if (infos.changed === 'removed') {
          return setValue(removed, fieldName, infos.value, options);
        } else if (infos.changed === 'primitive change') {
          setValue(removed, fieldName, infos.removed, options);
          return setValue(added, fieldName, infos.added, options);
        }
      };
      added = {};
      removed = {};
      diff = objectdiff.diff(this._cachedProperties, this._properties);
      if (diff.changed === 'object change') {
        _ref = diff.value;
        for (fieldName in _ref) {
          infos = _ref[fieldName];
          if (infos.changed === 'object change') {
            if (this.schema[fieldName].i18n) {
              _ref1 = infos.value;
              for (lang in _ref1) {
                linfos = _ref1[lang];
                if (linfos.changed === 'object change') {
                  _ref2 = linfos.value;
                  for (index in _ref2) {
                    mlinfos = _ref2[index];
                    setDiff(fieldName, mlinfos, {
                      i18n: true,
                      lang: lang,
                      multi: true
                    });
                  }
                } else {
                  setDiff(fieldName, linfos, {
                    i18n: true,
                    lang: lang
                  });
                }
              }
            } else if (this.schema[fieldName].multi) {
              _ref3 = infos.value;
              for (index in _ref3) {
                minfos = _ref3[index];
                setDiff(fieldName, minfos, {
                  multi: true
                });
              }
            }
          } else {
            setDiff(fieldName, infos);
          }
        }
        return {
          added: added,
          removed: removed
        };
      }
      return null;
    };

    Model.prototype.save = function(callback) {
      var e;
      if (!callback) {
        throw 'callback is required';
      }
      if (typeof callback !== 'function') {
        throw 'callback should be a function';
      }
      try {
        this.__checkRequiredFields();
      } catch (_error) {
        e = _error;
        return callback(e.message);
      }
      return async.map(this._getPendingRelations(), function(model, cb) {
        return model.save(function(err, obj, infos) {
          if (err) {
            return cb(err);
          }
          return cb(null, infos);
        });
      }, (function(_this) {
        return function(err, results) {
          var dbTouched;
          if (err) {
            return callback(err);
          }
          dbTouched = _.some(_.map(results, function(obj) {
            return obj.dbTouched;
          }));
          return _this.db.sync(_this.toSerializableObject(), function(err, obj, infos) {
            if (err) {
              return callback(err);
            }
            if (infos.dbTouched) {
              _this._isNew = false;
              if (_this.id == null) {
                _this.set('_id', obj._id);
              }
            }
            dbTouched = infos.dbTouched || dbTouched;
            _this._updateCachedProperties();
            return callback(null, _this, {
              dbTouched: dbTouched
            });
          });
        };
      })(this));
    };

    Model.prototype.beforeSave = function(next) {
      return next();
    };

    Model.prototype.rollback = function() {
      var key, lang, val, value, _ref, _results;
      this._properties = {};
      _ref = this._cachedProperties;
      _results = [];
      for (key in _ref) {
        value = _ref[key];
        if (_.isArray(value)) {
          _results.push(this._properties[key] = _.clone(value));
        } else if (_.isObject(value) && !_.isArray(value)) {
          if (!this._properties[key]) {
            this._properties[key] = {};
          }
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (lang in value) {
              val = value[lang];
              _results1.push(this._properties[key][lang] = val);
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(this._properties[key] = value);
        }
      }
      return _results;
    };

    Model.prototype["delete"] = function(callback) {
      if (!callback) {
        throw 'callback is required';
      }
      if (!this.id) {
        return callback("can't delete a non-saved model");
      }
      return this.db["delete"](this.id, (function(_this) {
        return function(err) {
          if (err) {
            if (callback) {
              return callback(err);
            }
            return;
          }
          _this._isNew = true;
          _this._cachedProperties = {};
          if (callback) {
            return callback(null);
          }
        };
      })(this));
    };

    Model.prototype.clone = function() {
      var clonedObj, props;
      props = this.toJSONObject();
      delete props._id;
      clonedObj = new this.db[this.meta.name](this.toJSONObject());
      delete clonedObj._properties._id;
      delete clonedObj.id;
      return clonedObj;
    };

    Model.prototype.isNew = function() {
      return this._isNew;
    };

    Model.prototype.toJSONObject = function(options) {
      var jsonObject, key, lang, val, value, _i, _len, _ref, _ref1, _ref2;
      options = options || {};
      jsonObject = {};
      _ref = this._properties;
      for (key in _ref) {
        value = _ref[key];
        if (this.schema[key].multi && !this.schema[key].i18n) {
          if (!_.isArray(value)) {
            value = [value];
          }
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            val = value[_i];
            if (jsonObject[key] == null) {
              jsonObject[key] = [];
            }
            if (((_ref1 = val.meta) != null ? _ref1.name : void 0) && (val.toJSONObject != null)) {
              if (options.populate) {
                if (options.populate === 'ref') {
                  jsonObject[key].push({
                    _id: val.id,
                    _type: val.type
                  });
                } else {
                  jsonObject[key].push(val.toJSONObject(options));
                }
              } else {
                jsonObject[key].push(val.id);
              }
            } else {
              jsonObject[key].push(val);
            }
          }
        } else if (_.isObject(value) && !_.isArray(value) && !_.isDate(value)) {
          if (jsonObject[key] == null) {
            jsonObject[key] = {};
          }
          if (((_ref2 = value.meta) != null ? _ref2.name : void 0) && (value.toJSONObject != null)) {
            if (options.populate) {
              if (options.populate === 'ref') {
                jsonObject[key] = {
                  _id: value.id,
                  _type: value.type
                };
              } else {
                jsonObject[key] = value.toJSONObject(options);
              }
            } else {
              jsonObject[key] = value.id;
            }
          } else {
            for (lang in value) {
              val = value[lang];
              jsonObject[key][lang] = val;
            }
          }
        } else {
          jsonObject[key] = value;
        }
      }
      return jsonObject;
    };

    Model.prototype.toSerializableObject = function(options) {
      options = options || {};
      options.populate = false;
      return this.toJSONObject(options);
    };

    Model.prototype.serialize = function(options) {
      return this.toSerializableObject(options);
    };

    Model.prototype.toJSON = function(options) {
      return JSON.stringify(this.toJSONObject(options));
    };

    Model.prototype.__parseOptions = function(options, defaultValues, fieldName) {
      var key, value;
      options = options || {};
      if (fieldName) {
        if (_.isString(options)) {
          if (this.schema[fieldName].i18n) {
            options = {
              lang: options
            };
          } else {
            throw "bad options: " + this.meta.name + "." + fieldName + " is not i18n";
          }
        }
        if (this.schema[fieldName].i18n && !options.lang) {
          throw "" + this.meta.name + "." + fieldName + " is i18n and need a language";
        }
      }
      for (key in defaultValues) {
        value = defaultValues[key];
        if (options[key] == null) {
          options[key] = value;
        }
      }
      return options;
    };

    Model.prototype.__checkFieldExistance = function(fieldName) {
      if (this.schema[fieldName] == null) {
        throw "'" + this.meta.name + "." + fieldName + "' not found";
      }
    };

    Model.prototype.__checkRequiredFields = function() {
      var field, fieldName, keys, lang, ok, values, _ref, _ref1, _results;
      _ref = this.schema;
      _results = [];
      for (fieldName in _ref) {
        field = _ref[fieldName];
        if (field.required) {
          ok = true;
          if (this._properties[fieldName] == null) {
            ok = false;
          } else if (field.i18n) {
            keys = _.keys(this._properties[fieldName]);
            if (keys.length === 0) {
              ok = false;
            } else if (field.multi) {
              _ref1 = this._properties[fieldName];
              for (lang in _ref1) {
                values = _ref1[lang];
                if (values.length === 0) {
                  ok = false;
                }
              }
            }
          } else if (field.multi) {
            if (this._properties[fieldName].length === 0) {
              ok = false;
            }
          }
          if (!ok) {
            throw new ValueError("" + this.meta.name + "." + fieldName + " is required");
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Model.prototype.__processValue = function(value, attrs) {
      value = this.__computeValue(value, attrs);
      this.__validateValue(value, attrs);
      return value;
    };

    Model.prototype.__validateValue = function(value, attrs) {
      var ok, type, _ref;
      type = this.schema[attrs.fieldName].type;
      ok = true;
      if (this.db._types[type] != null) {
        if (!this.db._types[type].validate(value)) {
          ok = false;
        }
      } else if ((this.db[type] != null) && type !== ((_ref = value.meta) != null ? _ref.name : void 0) && !_.isString(value) && (value._id == null)) {
        ok = false;
      }
      if (!ok) {
        throw new ValueError("" + this.meta.name + "." + attrs.fieldName + " must be a " + type);
      }
    };

    Model.prototype.__computeValue = function(value, attrs) {
      var fieldName, lang, type, _ref;
      fieldName = attrs.fieldName;
      lang = attrs.lang;
      type = this.schema[fieldName].type;
      if (((_ref = this.db._types[type]) != null ? _ref.compute : void 0) != null) {
        value = this.db._types[type].compute(value, attrs);
      }
      if (this.schema[fieldName].compute != null) {
        return this.schema[fieldName].compute(value, attrs);
      }
      return value;
    };

    Model.prototype._getPendingRelations = function() {
      var fieldName, lang, pendings, schema, val, value, _ref;
      pendings = [];
      _ref = this._properties;
      for (fieldName in _ref) {
        value = _ref[fieldName];
        schema = this.schema[fieldName];
        if (this.db[schema.type] != null) {
          if (schema.i18n) {
            for (lang in value) {
              val = value[lang];
              if (schema.multi) {
                pendings = _.union(pendings, val);
              } else {
                pendings.push(val);
              }
            }
          } else if (schema.multi) {
            pendings = _.union(pendings, value);
          } else {
            pendings.push(value);
          }
        }
      }
      return pendings;
    };

    Model.prototype._updateCachedProperties = function() {
      var key, lang, val, value, _ref, _results;
      this._cachedProperties = {};
      _ref = this._properties;
      _results = [];
      for (key in _ref) {
        value = _ref[key];
        if (_.isArray(value)) {
          _results.push(this._cachedProperties[key] = _.clone(value));
        } else if (_.isObject(value) && !_.isArray(value)) {
          if (!this._cachedProperties[key]) {
            this._cachedProperties[key] = {};
          }
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (lang in value) {
              val = value[lang];
              _results1.push(this._cachedProperties[key][lang] = val);
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(this._cachedProperties[key] = value);
        }
      }
      return _results;
    };

    Model._validateQuery = function(model, mongoQuery) {
      var field, lang, newQuery, relation, relationModel, value, _ref, _ref1, _results;
      if (_.isString(mongoQuery) || _.isArray(mongoQuery)) {
        return;
      }
      _results = [];
      for (field in mongoQuery) {
        value = mongoQuery[field];
        if (field === '$and') {
          continue;
        }
        if (field.indexOf('@') > -1) {
          _ref = field.split('@'), field = _ref[0], lang = _ref[1];
        }
        if (field.indexOf('.') > -1) {
          _ref1 = field.split('.'), relation = _ref1[0], field = _ref1[1];
          if (model.prototype.schema[relation] == null) {
            throw "Unknown field " + model.prototype.meta.name + "." + relation;
          }
          relationModel = this.db[model.prototype.schema[relation].type];
          if (!relationModel) {
            throw "" + model.prototype.meta.name + "." + relation + " is not a model";
          }
          if (_.isArray(field)) {
            field = field.join('.');
          }
          newQuery = {};
          newQuery[field] = value;
          _results.push(this._validateQuery(relationModel, newQuery));
        } else if (model.prototype.schema[field] == null) {
          throw "Unknown field " + model.prototype.meta.name + "." + field;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Model;

  })();

  module.exports = Model;

}).call(this);
