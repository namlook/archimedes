// Generated by CoffeeScript 1.7.1
(function() {
  var defaultTypes, field2uri, operators, value2rdf, _, _buildProperty, _convert, _getStatement;

  _ = require('underscore');

  _.str = require('underscore.string');

  defaultTypes = require('../interface/types').defaultTypes;

  operators = {
    '$gt': '>',
    '$gte': '>=',
    '$lt': '<',
    '$lte': '<='
  };

  exports.mongo2sparql = function(mongoQuery, queryOptions, options) {
    var lang, order, prop, propuri, s, sortBy, sparqlLimit, sparqlOrder, sparqlQuery, v, validx, _i, _len, _ref;
    mongoQuery = mongoQuery || {};
    queryOptions = queryOptions || {};
    options = options || {};
    sparqlQuery = [];
    sparqlOrder = [];
    sparqlLimit = '';
    if (_.isEmpty(mongoQuery) && (queryOptions.sortBy == null)) {
      sparqlQuery.push('?s ?p ?o .');
    } else {
      validx = 0;
      _convert(sparqlQuery, mongoQuery, validx);
    }
    if (((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sparqlQuery.length; _i < _len; _i++) {
        s = sparqlQuery[_i];
        if (_.str.startsWith(s, 'MINUS')) {
          _results.push(1);
        }
      }
      return _results;
    })()).length === sparqlQuery.length) {
      sparqlQuery.push('?s ?p ?o .');
    }
    if (options.queryOnly) {
      return sparqlQuery.join('\n');
    }
    if (queryOptions.sortBy != null) {
      sortBy = queryOptions.sortBy;
      if (_.isString(sortBy)) {
        sortBy = [sortBy];
      }
      if (sortBy.length) {
        sparqlOrder.push('order by');
        for (_i = 0, _len = sortBy.length; _i < _len; _i++) {
          prop = sortBy[_i];
          lang = '';
          order = 'asc';
          if (prop[0] === '-') {
            order = 'desc';
            prop = prop.slice(1);
          }
          if (prop.indexOf('@') > -1) {
            _ref = prop.split('@'), prop = _ref[0], lang = _ref[1];
          }
          if ((mongoQuery[prop] == null) || !((function() {
            var _j, _len1, _ref1, _results;
            _ref1 = (mongoQuery['$and'] != null) || [];
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              v = _ref1[_j];
              if (v[prop] != null) {
                _results.push(1);
              }
            }
            return _results;
          })()).length) {
            prop = _buildProperty(prop);
            propuri = "" + (_.str.classify(prop)) + lang;
            sparqlQuery.push("?s " + prop + " ?" + propuri + " .");
            if (lang) {
              sparqlQuery.push("filter (lang(?" + propuri + ") = '" + lang + "')");
            }
          }
          sparqlOrder.push("" + order + "(?" + (_.str.classify(prop)) + lang + ")");
        }
      }
    }
    if (queryOptions.limit != null) {
      sparqlLimit = "limit " + queryOptions.limit;
    }
    return "{" + (sparqlQuery.join('\n')) + "}\n" + (sparqlOrder.join(' ')) + "\n" + sparqlLimit;
  };

  _convert = function(sparqlQuery, query, validx) {
    var prop, val, value, _results;
    _results = [];
    for (prop in query) {
      value = query[prop];
      if (prop === '$and') {
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = value.length; _i < _len; _i++) {
            val = value[_i];
            _convert(sparqlQuery, val, validx);
            _results1.push(validx += 1);
          }
          return _results1;
        })());
      } else {
        sparqlQuery.push(_getStatement(prop, value, validx));
        _results.push(validx += 1);
      }
    }
    return _results;
  };

  _buildProperty = function(prop) {
    var _prop;
    if (prop.indexOf('->') > -1) {
      prop = ((function() {
        var _i, _len, _ref, _results;
        _ref = prop.split('->');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _prop = _ref[_i];
          _results.push("<" + _prop + ">");
        }
        return _results;
      })()).join('/');
    } else if (prop === '_type') {
      prop = 'a';
    } else {
      prop = "<" + prop + ">";
    }
    return prop;
  };

  _getStatement = function(prop, value, validx) {
    var $op, addVariableStatement, filter, isNot, lang, minus, notExists, op, sparqlQuery, v, val, vals, variable, varidx, _i, _len, _ref, _val, _variable;
    sparqlQuery = [];
    lang = '';
    isNot = false;
    addVariableStatement = true;
    if (prop.indexOf('@') > -1) {
      _ref = prop.split('@'), prop = _ref[0], lang = _ref[1];
    }
    variable = "?" + (_.str.classify(prop)) + lang + validx;
    prop = _buildProperty(prop);
    if (_.isRegExp(value)) {
      throw 'regex not implemented';
    }
    if (_.isObject(value) && !_.isDate(value) && (value._uri == null)) {
      for ($op in value) {
        val = value[$op];
        if ($op === '$gt' || $op === '$lt' || $op === '$gte' || $op === '$lte') {
          if (prop === 'a') {
            val = {
              _id: val
            };
          }
          _val = value2rdf(val, lang);
          op = operators[$op];
          sparqlQuery.push("filter (" + variable + " " + op + " " + _val + ")");
        } else if ($op === '$in' || $op === '$nin') {
          if ($op === '$nin') {
            isNot = true;
          }
          if (!_.isArray(val)) {
            val = [val];
          }
          val = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = val.length; _i < _len; _i++) {
              v = val[_i];
              _results.push(prop === 'a' && {
                _id: v
              } || v);
            }
            return _results;
          })();
          vals = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = val.length; _i < _len; _i++) {
              v = val[_i];
              _results.push(value2rdf(v, lang));
            }
            return _results;
          })();
          filter = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = vals.length; _i < _len; _i++) {
              v = vals[_i];
              _results.push("" + variable + " = " + v);
            }
            return _results;
          })();
          sparqlQuery.push("filter (" + (filter.join(' || ')) + ")");
        } else if ($op === '$all' || $op === '$nall') {
          if ($op === '$nall') {
            isNot = true;
          }
          if (!_.isArray(val)) {
            val = [val];
          }
          _variable = variable;
          varidx = 0;
          for (_i = 0, _len = val.length; _i < _len; _i++) {
            _val = val[_i];
            if (_variable !== variable) {
              sparqlQuery.push("?s " + prop + " " + _variable);
            }
            if (prop === 'a') {
              _val = {
                _id: _val
              };
            }
            _val = value2rdf(_val, lang);
            sparqlQuery.push("filter (" + _variable + " = " + _val + ")");
            varidx += 1;
            _variable = "" + variable + varidx;
          }
        } else if ($op === '$exists') {
          notExists = '';
          addVariableStatement = false;
          if (!val) {
            notExists = 'not';
          }
          sparqlQuery.push("?s ?p ?o");
          sparqlQuery.push("filter (" + notExists + " exists {?s " + prop + " " + variable + "})");
        } else if ($op === '$ne') {
          isNot = true;
          if (prop === 'a') {
            val = {
              _id: val
            };
          }
          _val = value2rdf(val, lang);
          sparqlQuery.push("filter (" + variable + " = " + _val + ")");
        } else {
          throw "unknown operator " + $op;
        }
      }
    } else {
      if (prop === 'a') {
        value = {
          _id: value
        };
      }
      value = value2rdf(value, lang);
      sparqlQuery.push("filter (" + variable + " = " + value + ")");
    }
    if (addVariableStatement) {
      sparqlQuery.push("?s " + prop + " " + variable);
    }
    sparqlQuery = sparqlQuery.join(' .\n');
    minus = '';
    if (isNot) {
      minus = "MINUS ";
    }
    sparqlQuery = "" + minus + "{" + sparqlQuery + "}";
    return sparqlQuery;
  };

  exports.value2rdf = value2rdf = function(value, lang) {
    var quotedValue, type, utcdate;
    if (lang && !_.isString(value)) {
      throw 'i18n fields accept only strings';
    }
    if (value._id != null) {
      value = "<" + value._id + ">";
    } else if (_.isBoolean(value)) {
      value = "\"" + value + "\"^^xsd:boolean";
    } else if (_.isDate(value)) {
      utcdate = new Date(value.toUTCString()).toISOString();
      value = "\"" + utcdate + "\"^^xsd:dateTime";
    } else if (_.isNumber(value) && !lang) {
      if (defaultTypes.integer.validate(value)) {
        type = 'integer';
      } else if (defaultTypes.float.validate(value)) {
        type = 'float';
      } else {
        throw "unknown number's type: " + value;
      }
      value = "\"" + value + "\"^^xsd:" + type;
    } else {
      quotedValue = value.replace(/"/g, '\\"');
      lang = lang ? "@" + lang : '';
      value = "\"\"\"" + quotedValue + "\"\"\"" + lang;
    }
    return value;
  };

  exports.field2uri = field2uri = function(fieldName, model) {
    var fields, lang, meta, name, newfieldName, newmodel, schema, uri, _ref;
    schema = model.prototype.schema;
    meta = model.prototype.meta;
    if (fieldName.indexOf('@') > -1) {
      _ref = fieldName.split('@'), name = _ref[0], lang = _ref[1];
    } else {
      name = fieldName;
    }
    if (fieldName.indexOf('.') > -1) {
      fields = fieldName.split('.');
      fieldName = fields[0];
      if (schema[fieldName] == null) {
        throw "Unknown field " + meta.name + "." + fieldName;
      }
      newmodel = model.db[model.prototype.schema[fieldName].type];
      newfieldName = fields.slice(1).join('.');
      uri = schema[fieldName].uri || ("" + meta.propertiesNamespace + "/" + fieldName);
      return "" + uri + "->" + (field2uri(newfieldName, newmodel));
    } else {
      if (schema[name] == null) {
        throw "Unknown field " + meta.name + "." + name;
      }
      return schema[name].uri || ("" + meta.propertiesNamespace + "/" + fieldName);
    }
  };

  exports.buildTimeSeriesQuery = function(step) {
    var concat, key, modifiers, nbSteps, s, stepIndex, steps, v, _i, _j, _len, _len1, _ref, _step, _value;
    stepIndex = {
      'year': false,
      'month': false,
      'day': false,
      'hours': false,
      'minutes': false,
      'seconds': false
    };
    _ref = step.split('$');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _step = _ref[_i];
      for (key in stepIndex) {
        _value = stepIndex[key];
        if (_.str.startsWith(_step, key)) {
          stepIndex[key] = true;
          nbSteps += 1;
        }
      }
    }
    steps = (function() {
      var _results;
      _results = [];
      for (s in stepIndex) {
        v = stepIndex[s];
        if (v === true) {
          _results.push(s);
        }
      }
      return _results;
    })();
    nbSteps = steps.length;
    modifiers = [];
    if (nbSteps === 0) {
      throw 'timeSeries requires a step';
    } else if (nbSteps === 1) {
      concat = "" + steps[0] + "(?date)";
    } else {
      for (_j = 0, _len1 = steps.length; _j < _len1; _j++) {
        _step = steps[_j];
        step = step.replace("$" + _step, "\", ?" + _step + ", \"");
        modifiers.push("bind(str(" + _step + "(?date)) as ?_" + _step + ") .\nbind(if(strlen(?_" + _step + ") = 1, concat('0', ?_" + _step + "), ?_" + _step + ") as ?" + _step + ") .");
      }
      concat = "concat(\"" + step + "\")";
    }
    return {
      'modifiers': modifiers.join('\n'),
      'groupBy': "(" + concat + " as ?facet)"
    };
  };

  if (require.main === module) {
    console.log(exports.buildTimeSeriesQuery('$year-$month/$seconds'));
  }

}).call(this);
